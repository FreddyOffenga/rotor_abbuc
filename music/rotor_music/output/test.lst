mads 1.9.9
Source: C:\Users\Freddy\Documents\Projects\wudsn\Freddy\2023\2023 ROTOR\rotor_abbuc\music\rotor_music\test.asm
     1 				;
     2 				; LZSS Compressed SAP player for 16 match bits
     3 				; --------------------------------------------
     4 				;
     5 				; (c) 2020 DMSC
     6 				; Code under MIT license, see LICENSE file.
     7 				;
     8 				; This player uses:
     9 				;  Match length: 8 bits  (1 to 256)
    10 				;  Match offset: 8 bits  (1 to 256)
    11 				;  Min length: 2
    12 				;  Total match bits: 16 bits
    13 				;
    14 				; Compress using:
    15 				;  lzss -b 16 -o 8 -m 1 input.rsap test.lz16
    16 				;
    17 				; Assemble this file with MADS assembler, the compressed song is expected in
    18 				; the `test.lz16` file at assembly time.
    19 				;
    20 				; The plater needs 256 bytes of buffer for each pokey register stored, for a
    21 				; full SAP file this is 2304 bytes.
    22 				;
    23
    24 = 0232			SSKCTL = $0232
    25 = D20A			RANDOM = $d20a
    26 = D20F			SKCTL  = $d20f
    27
    28 				    org $80
    29
    30 				zp
    31 = 0080			chn_copy    .ds     9
    32 = 0089			chn_pos     .ds     9
    33 = 0092			bptr        .ds     2
    34 = 0094			cur_pos     .ds     1
    35 = 0095			chn_bits    .ds     1
    36 FFFF> 0096-0096> 01	bit_data    .byte   1
    37
    38 = 0097			newsong     .ds     1       ; IVO
    39
    40 = 0098			stereo_pokey    .ds     1
    41
    42 0099			.proc get_byte
    43 0099-00A2> AD 34 12	    lda $1234
    44 009C E6 9A		    inc song_ptr
    45 009E D0 02		    bne skip
    46 00A0 E6 9B		    inc song_ptr+1
    47 00A2			skip
    48 00A2 60			    rts
    49 				.endp
    50 = 009A			song_ptr = get_byte + 1
    51
    52
    53 = D200			POKEY = $D200
    54
    55 00A3			    org $2000
    56 2000			buffers
    57 = 2000			    .ds 256 * 9
    58
    59 2900			intro_data
    60 2900-3B7F> 01 01 A1 34 +         ins     'intro.lz16'
    61 2BD8			intro_end
    62
    63 2BD8			loop_data
    64 2BD8 01 01 A1 34 00 10 +         ins     'loop.lz16'
    65 39D9			loop_end
    66
    67
    68 39D9			start
    69
    70 				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    71 				; Song Initialization - this runs in the first tick:
    72 				;
    73 39D9			.proc play_first_frame
    74
    75 39D9 20 99 00		    jsr get_byte                    ; IVO START move init here
    76 39DC 8D 18 3A		    sta play_frame.init_chn_bits
    77 39DF A9 01		    lda #1                          ; IVO set to 1 at init(!)
    78 39E1 85 96		    sta bit_data
    79 39E3 A9 20		    lda #>buffers                   ; IVO reset cbuf+1 pointer
    80 39E5 8D F8 39		    sta cbuf+2                      ; IVO END
    81
    82 				    ; Init all channels:
    83 39E8 A2 08		    ldx #8
    84 39EA A0 00		    ldy #0
    85 39EC 84 97		    sty newsong                     ; IVO signal first frame is played
    86 39EE			clear
    87 				    ; Read just init value and store into buffer and POKEY
    88 39EE 20 99 00		    jsr get_byte
    89 39F1 9D 80 3B		    sta SHADOW, x
    90 39F4 94 80		    sty chn_copy, x
    91 39F6			cbuf
    92 39F6 8D FF 20		    sta buffers + 255
    93 39F9 EE F8 39		    inc cbuf + 2
    94 39FC CA			    dex
    95 39FD 10 EF		    bpl clear
    96
    97 				    ; Initialize buffer pointer:
    98 39FF 84 92		    sty bptr
    99 3A01 84 94		    sty cur_pos
   100 3A03 60			    rts                     ; IVO turn into subroutine
   101 				.endp
   102
   103 				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   104 				; Wait for next frame
   105 				;
   106 3A04			.proc wait_frame
   107
   108 3A04 A5 14		    lda 20
   109 3A06			delay
   110 3A06 C5 14		    cmp 20
   111 3A08 F0 FC		    beq delay
   112 3A0A 60			    rts                     ; IVO turn into subroutine
   113 				.endp
   114
   115 				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   116 				; Play one frame of the song
   117 				;
   118 3A0B			.proc play_frame
   119 3A0B A5 97		    lda newsong
   120 3A0D F0 02		    beq continue
   121 3A0F D0 C8		    bne play_first_frame
   122
   123 3A11			continue
   124 3A11 A4 94		    ldy cur_pos                 ; IVO
   125
   126 3A13 A9 20		    lda #>buffers
   127 3A15 85 93		    sta bptr+1
   128
   129 = 3A18			init_chn_bits=*+1
   130 3A17 A9 00		    lda #0              ; IVO: 8 bits, but 9 streams. bug?
   131 3A19 85 95		    sta chn_bits
   132 3A1B A2 08		    ldx #8
   133
   134 				    ; Loop through all "channels", one for each POKEY register
   135 3A1D			chn_loop:
   136 3A1D 46 95		    lsr chn_bits
   137 3A1F B0 29		    bcs skip_chn       ; C=1 : skip this channel
   138
   139 3A21 B5 80		    lda chn_copy, x    ; Get status of this stream
   140 3A23 D0 16		    bne do_copy_byte   ; If > 0 we are copying bytes
   141
   142 				    ; We are decoding a new match/literal
   143 3A25 46 96		    lsr bit_data       ; Get next bit
   144 3A27 D0 06		    bne got_bit
   145 3A29 20 99 00		    jsr get_byte       ; Not enough bits, refill!
   146 3A2C 6A			    ror                ; Extract a new bit and add a 1 at the high bit (from C set above)
   147 3A2D 85 96		    sta bit_data       ;
   148 3A2F			got_bit:
   149 3A2F 20 99 00		    jsr get_byte       ; Always read a byte, it could mean "match size/offset" or "literal byte"
   150 3A32 B0 0F		    bcs store          ; Bit = 1 is "literal", bit = 0 is "match"
   151
   152 3A34 95 89		    sta chn_pos, x     ; Store in "copy pos"
   153
   154 3A36 20 99 00		    jsr get_byte
   155 3A39 95 80		    sta chn_copy, x    ; Store in "copy length"
   156
   157 				                        ; And start copying first byte
   158 3A3B			do_copy_byte:
   159 3A3B D6 80		    dec chn_copy, x     ; Decrease match length, increase match position
   160 3A3D F6 89		    inc chn_pos, x
   161 3A3F B4 89		    ldy chn_pos, x
   162
   163 				    ; Now, read old data, jump to data store
   164 3A41 B1 92		    lda (bptr), y
   165
   166 3A43			store:
   167 3A43 A4 94		    ldy cur_pos
   168 3A45 9D 80 3B		    sta SHADOW, x        ; Store to output and buffer
   169 3A48 91 92		    sta (bptr), y
   170
   171 3A4A			skip_chn:
   172 				    ; Increment channel buffer pointer
   173 3A4A E6 93		    inc bptr+1
   174
   175 3A4C CA			    dex
   176 3A4D 10 CE		    bpl chn_loop        ; Next channel
   177
   178 3A4F E6 94		    inc cur_pos
   179 3A51 60			    rts                 ; IVO once per frame
   180 				.endp
   181
   182 				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   183 				; Check for ending of song and jump to the next frame
   184 				;
   185 3A52			.proc check_end_song
   186 3A52 A5 9B		    lda song_ptr + 1
   187 = 3A55			song_end_high=*+1
   188 3A54 C9 00		    cmp #>0
   189 3A56 D0 08		    bne not_equal           ; IVO turn into subroutine
   190 3A58 A5 9A		    lda song_ptr
   191 = 3A5B			song_end_low=*+1
   192 3A5A C9 00		    cmp #<0
   193 3A5C D0 02		    bne not_equal           ; IVO turn intro subroutine
   194
   195 3A5E 38			    sec                     ; IVO....
   196 3A5F 60			    rts
   197 3A60			not_equal
   198 3A60 18			    clc
   199 3A61 60			    rts
   200 				.endp
   201
   202 				; IVO everything below
   203
   204 3A62			.proc main
   205 3A62 20 30 3B		    jsr detect_2nd_pokey
   206 3A65 20 69 3B		    jsr clear_echo
   207
   208 3A68 A9 9B 8D D4 3A A9 +     mwa #normal_volume adjust_volume.volume
   209 				;    mwa #half_volume adjust_volume.volume
   210 				;    mwa #quarter_volume adjust_volume.volume
   211
   212 3A72 A9 D8		    lda #<intro_end
   213 3A74 8D 5B 3A		    sta check_end_song.song_end_low
   214 3A77 A9 2B		    lda #>intro_end
   215 3A79 8D 55 3A		    sta check_end_song.song_end_high
   216 3A7C A9 00		    lda #<(intro_data)
   217 3A7E 85 9A		    sta song_ptr
   218 3A80 A9 29		    lda #>(intro_data)
   219 3A82 85 9B		    sta song_ptr+1
   220 3A84 A9 01		    lda #1
   221 3A86 85 97		    sta newsong
   222
   223 3A88 20 AF 3A		    jsr play_song
   224
   225 3A8B			loop
   226 3A8B AD C6 02		    lda $02c6
   227 3A8E 69 18		    adc #$18
   228 3A90 8D C6 02		    sta $02c6
   229
   230 3A93 A9 D9		    lda #<loop_end
   231 3A95 8D 5B 3A		    sta check_end_song.song_end_low
   232 3A98 A9 39		    lda #>loop_end
   233 3A9A 8D 55 3A		    sta check_end_song.song_end_high
   234 3A9D A9 D8		    lda #<(loop_data)
   235 3A9F 85 9A		    sta song_ptr
   236 3AA1 A9 2B		    lda #>(loop_data)
   237 3AA3 85 9B		    sta song_ptr+1
   238 3AA5 A9 01		    lda #1
   239 3AA7 85 97		    sta newsong
   240
   241 3AA9 20 AF 3A		    jsr play_song
   242
   243 3AAC 4C 8B 3A		    jmp loop
   244 				.endp
   245
   246 3AAF			.proc play_song
   247 3AAF			playloop
   248 3AAF 20 0B 3A		    jsr play_frame      ; generates tick two and beyond
   249 3AB2 20 C4 3A		    jsr adjust_volume
   250 3AB5 20 04 3A		    jsr wait_frame
   251 3AB8 20 E1 3A		    jsr copy_shadow
   252
   253 3ABB 20 FF 3A		    jsr console_keys
   254
   255 3ABE 20 52 3A		    jsr check_end_song
   256 3AC1 90 EC		    bcc playloop
   257 3AC3 60			    rts
   258 				.endp
   259
   260 3AC4			.proc adjust_volume
   261 3AC4 A0 06		    ldy #6
   262 3AC6			adjust
   263 3AC6 B9 81 3B		    lda SHADOW+1,y
   264 3AC9 AA			    tax
   265 3ACA 29 F0		    and #$f0
   266 3ACC 99 81 3B		    sta SHADOW+1,y
   267 3ACF 8A			    txa
   268 3AD0 29 0F		    and #$0f
   269 3AD2 AA			    tax
   270 = 3AD4			volume=*+1
   271 3AD3 BD 34 12		    lda $1234,x
   272 3AD6 19 81 3B		    ora SHADOW+1,y
   273 3AD9 99 81 3B		    sta SHADOW+1,y
   274 3ADC 88			    dey
   275 3ADD 88			    dey
   276 3ADE 10 E6		    bpl adjust
   277 				    
   278 3AE0 60			    rts
   279 				.endp
   280
   281 3AE1			.proc copy_shadow
   282 3AE1 A2 08		    ldx #8
   283 3AE3			copy
   284 3AE3 BD 80 3B		    lda SHADOW,x
   285 3AE6 9D 00 D2		    sta POKEY,x
   286 3AE9 CA			    dex
   287 3AEA 10 F7		    bpl copy
   288
   289 3AEC A5 98		    lda stereo_pokey
   290 3AEE F0 0E		    beq end_copy
   291
   292 3AF0 A2 08		    ldx #8
   293 3AF2			copy2
   294 3AF2 BD 92 3B		    lda ECHO,x
   295 3AF5 9D 10 D2		    sta POKEY+$10,x
   296 3AF8 CA			    dex
   297 3AF9 10 F7		    bpl copy2
   298
   299 3AFB 20 74 3B		    jsr shift_echo
   300
   301 3AFE			end_copy
   302 3AFE 60			    rts
   303 				.endp
   304
   305 3AFF			.proc console_keys
   306 3AFF AD 1F D0		    lda $d01f
   307 3B02 C9 03		    cmp #3
   308 3B04 F0 09		    beq option
   309 3B06 C9 05		    cmp #5
   310 3B08 F0 10		    beq select
   311 3B0A C9 06		    cmp #6
   312 3B0C F0 17		    beq start
   313 3B0E 60			    rts
   314
   315 3B0F			option
   316 3B0F A9 9B 8D D4 3A A9 +     mwa #normal_volume adjust_volume.volume
   317 3B19 60			    rts
   318 3B1A			select
   319 3B1A A9 AB 8D D4 3A A9 +     mwa #half_volume adjust_volume.volume
   320 3B24 60			    rts
   321 3B25			start
   322 3B25 A9 BB 8D D4 3A A9 +     mwa #quarter_volume adjust_volume.volume
   323 3B2F 60			    rts
   324 				.endp
   325
   326 3B30			.proc detect_2nd_pokey
   327 3B30 20 04 3A		    jsr wait_frame
   328
   329 3B33 A9 00 8D 32 02	    mva #0 SSKCTL
   330 3B38 A9 00 8D 0F D2	    mva #0 SKCTL
   331 3B3D A9 00 8D 1F D2	    mva #0 SKCTL+$10        ; make sure a potential 2nd pokey is cleared
   332
   333 3B42 20 04 3A		    jsr wait_frame
   334
   335 				    ; Restart SKCTL. This starts all the poly counters
   336
   337 3B45 A9 03 8D 32 02	    mva #3 SSKCTL
   338 3B4A A9 03 8D 0F D2	    mva #3 SKCTL
   339
   340 3B4F 20 04 3A		    jsr wait_frame
   341
   342 				    ; Except when there's a seconds pokey!! Its counters are not restarted.
   343 				    ; Its RANDOM should not change.
   344
   345 3B52 AD 1A D2		    lda RANDOM+$10
   346 3B55 CD 1A D2		    cmp RANDOM+$10
   347 3B58 F0 05		    beq detected_stereo         ; so equal means there's a 2nd pokey
   348
   349 3B5A			detected_mono
   350 3B5A A9 00 85 98		    mva #0 stereo_pokey
   351 3B5E 60			    rts
   352
   353 3B5F			detected_stereo
   354 3B5F A9 01 85 98		    mva #1 stereo_pokey
   355 3B63 A9 03 8D 1F D2	    mva #3 SKCTL+$10            ; start second pokey here
   356 3B68 60			    rts
   357 				.endp
   358
   359 3B69			.proc clear_echo
   360 3B69 A0 11		    ldy #(endecho-echobuffer)-1
   361 3B6B			clear_echo_loop
   362 3B6B A9 00 99 89 3B	    mva #0 echobuffer,y
   363 3B70 88 10 F8		    dey:bpl clear_echo_loop
   364 3B73 60			    rts
   365 				.endp
   366
   367 3B74			.proc shift_echo
   368 3B74 A0 11		    ldy #(ECHO-echobuffer)-1+9
   369 3B76			shift_loop
   370 3B76 B9 80 3B 99 89 3B	    mva SHADOW,y SHADOW+9,y
   371 3B7C 88 10 F7		    dey:bpl shift_loop
   372 3B7F 60			    rts
   373 				.endp
   374
   375 3B80			SHADOW              ; shadow pokey
   376 = 3B80			    .ds 9
   377
   378 				                    ; fake stereo effect:
   379 				                    ; 0*9 = small
   380 				                    ; 1*9 = medium
   381 				                    ; 2*9 = big
   382 				                    ; >3 too big imho
   383
   384 3B89			echobuffer
   385 = 3B89			    .ds 1*9        ; total of echobuffer+ECHO MUST NOT exceed 128 bytes
   386
   387 3B92			ECHO
   388 = 3B92			    .ds 9
   389 3B9B			endecho
   390
   391 3B9B			normal_volume
   392 3B9B-3BCC> 00 01 02 03 +     dta 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15
   393 3BAB			half_volume
   394 3BAB 00 01 01 02 02 03 +     dta 0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,7
   395 3BBB			quarter_volume
   396 3BBB 00 01 01 01 01 02 +     dta 0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,4
   397
   398 02E0-02E1> 62 3A		    run main
   399
